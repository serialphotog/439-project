{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/calc.js","src/lib/engine.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","Calculator","toPostfix","console","log","res","calc","this","expression","out","stack","operators","^","precedence","associativity","/","*","+","-","replace","split","clean","token","isNumeric","indexOf","b","pop","push","postfix","parseFloat","Math","pow","String","prototype","isNaN","isFinite","Array","splice"],"mappings":"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","file":"calc.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import {Calculator} from './lib/engine.js';\r\n\r\n// Testing shit\r\nvar c = new Calculator();\r\nvar a = c.toPostfix(\"5 + 3\");\r\nconsole.log(a);\r\nconsole.log(\"Soliving...\");\r\nvar res = c.calc(a);\r\nconsole.log(res);","/**\r\n * Checks is a string represents a numeric value.\r\n */\r\nString.prototype.isNumeric = function() {\r\n\treturn !isNaN(parseFloat(this)) && isFinite(this);\r\n}\r\n\r\n/**\r\n * Cleans empty items from an array.\r\n */\r\nArray.prototype.clean = function() {\r\n\tfor (var i=0; i < this.length; i++) {\r\n\t\tif (this[i] === \"\") {\r\n\t\t\tthis.splice(i, 1);\r\n\t\t}\r\n\t}\r\n\r\n\treturn this;\r\n}\r\n\r\nexport function Calculator() {\r\n\r\n\t// Converts an infix expression to postfix\r\n\t// This is using the Shunting Yard Algorithm\r\n\tthis.toPostfix = function(expression) {\r\n\t\tvar out = \"\"; // The output queue\r\n\t\tvar stack = []; // The operators stack\r\n\r\n\t\t// Opeartor definitions\r\n\t\tvar operators = {\r\n\t\t\t\"^\": {\r\n\t\t\t\tprecedence: 4,\r\n\t\t\t\tassociativity: \"right\"\r\n\t\t\t},\r\n\r\n\t\t\t\"/\": {\r\n\t\t\t\tprecedence: 3,\r\n\t\t\t\tassociativity: \"left\"\r\n\t\t\t}, \r\n\r\n\t\t\t\"*\": {\r\n\t\t\t\tprecedence: 3,\r\n\t\t\t\tassociativity: \"left\"\r\n\t\t\t},\r\n\r\n\t\t\t\"+\": {\r\n\t\t\t\tprecedence: 2,\r\n\t\t\t\tassociativity: \"left\"\r\n\t\t\t},\r\n\r\n\t\t\t\"-\": {\r\n\t\t\t\tprecedence: 2,\r\n\t\t\t\tassociativity: \"left\"\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Removes one or more occurences of whitespace globally\r\n\t\texpression = expression.replace(/\\s+/g, \"\");\r\n\t\t// Searches for operators and splits the expression on them\r\n\t\texpression = expression.split(/([\\+\\-\\*\\/\\^\\(\\)])/).clean();\r\n\r\n\t\t// Parse the expression\r\n\t\tfor (var i=0; i < expression.length; i++) {\r\n\t\t\tvar token = expression[i];\r\n\r\n\t\t\tif (token.isNumeric()) {\r\n\t\t\t\tout += token + \" \";\r\n\t\t\t} else if (\"^*/+-\".indexOf(token) !== -1) {\r\n\t\t\t\t// This is an operator token\r\n\t\t\t\tvar a = token;\r\n\t\t\t\tvar b = stack[stack.length - 1];\r\n\r\n\t\t\t\twhile (\"^*/+-\".indexOf(b) !== -1 && ((operators[a].associativity == \"left\" && operators[a].precedence <= operators[b].precedence) || \r\n\t\t\t\t\toperators[a].associativity == \"right\" && operators[b].precedence < operators[b].precedence)) {\r\n\t\t\t\t\tout += stack.pop() + \" \";\r\n\t\t\t\t\tb = stack[stack.length - 1];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstack.push(a);\r\n\t\t\t} else if (token == \"(\") {\r\n\t\t\t\tstack.push(token);\r\n\t\t\t} else if (token == \")\") {\r\n\t\t\t\twhile (stack[stack.length - 1] !== \"(\") {\r\n\t\t\t\t\tout += stack.pop() + \" \";\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstack.pop();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twhile (stack.length > 0) {\r\n\t\t\tout += stack.pop() + \" \";\r\n\t\t}\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\t// Given an expression in postifx, solve it\r\n\tthis.calc = function(postfix) {\r\n\t\tvar stack = []; // The result stack\r\n\r\n\t\t// Split the postfix on spaces\r\n\t\tpostfix = postfix.split(\" \").clean();\r\n\r\n\t\t// Solve it!\r\n\t\tfor (var i=0; i < postfix.length; i++) {\r\n\t\t\tif (postfix[i].isNumeric()) {\r\n\t\t\t\tstack.push(postfix[i]);\r\n\t\t\t} else { // Operator\r\n\t\t\t\tvar a = stack.pop();\r\n\t\t\t\tvar b = stack.pop();\r\n\r\n\t\t\t\tif (postfix[i] === \"+\") {\r\n\t\t\t\t\tstack.push(parseFloat(a) + parseFloat(b));\r\n\t\t\t\t} else if (postfix[i] === \"-\") {\r\n\t\t\t\t\tstack.push(parseFloat(b) - parseFloat(a));\r\n\t\t\t\t} else if (postfix[i] === \"*\") {\r\n\t\t\t\t\tstack.push(parseFloat(a) * parseFloat(b));\r\n\t\t\t\t} else if (postfix[i] === \"/\") {\r\n\t\t\t\t\tstack.push(parseFloat(b) / parseFloat(a));\r\n\t\t\t\t} else if (postfix[i] === \"^\") {\r\n\t\t\t\t\tstack.push(Math.pow(parseFloat(b), parseFloat(a)));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (stack.length > 1) {\r\n\t\t\treturn \"Syntax Error\";\r\n\t\t} else {\r\n\t\t\treturn stack.pop();\r\n\t\t}\r\n\t}\r\n\r\n}"]}