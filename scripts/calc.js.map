{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/calc.js","src/lib/engine.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","Calculator","toPostfix","console","log","res","calc","this","expression","out","stack","operators","^","precedence","associativity","/","*","+","-","replace","split","clean","token","isNumeric","indexOf","b","pop","push","postfix","parseFloat","Math","pow","String","prototype","isNaN","isFinite","Array","splice","Function","Object","hasOwnProperty","PI","LOG2E","E"],"mappings":"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","file":"calc.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import {Calculator} from './lib/engine.js';\r\n\r\n// Testing shit\r\nvar c = new Calculator();\r\nvar a = c.toPostfix(\"5 + 3\");\r\nconsole.log(a);\r\nconsole.log(\"Soliving...\");\r\nvar res = c.calc(a);\r\nconsole.log(res);","/**\r\n * Checks is a string represents a numeric value.\r\n */\r\nString.prototype.isNumeric = function() {\r\n\treturn !isNaN(parseFloat(this)) && isFinite(this);\r\n}\r\n\r\n/**\r\n * Cleans empty items from an array.\r\n */\r\nArray.prototype.clean = function() {\r\n\tfor (var i=0; i < this.length; i++) {\r\n\t\tif (this[i] === \"\") {\r\n\t\t\tthis.splice(i, 1);\r\n\t\t}\r\n\t}\r\n\r\n\treturn this;\r\n}\r\n\r\nvar root = Function('return this')();\r\n\r\n// The various token types\r\nvar TokenType = {\r\n\tVAR: 'x',\r\n\tCALL: 'f',\r\n\tGROUP: '()',\r\n\tNUM: '#',\r\n\tOP: '*',\r\n\tL_PAREN: '(',\r\n\tR_PAREN: ')',\r\n\tCOMMA: ','\r\n};\r\n\r\nvar hasOwnProperty = Object.hasOwnProperty;\r\n\r\nvar Parser = function() {\r\n\t// Stores the order of operations\r\n\t// See: https://en.wikipedia.org/wiki/Order_of_operations#Programming_languages\r\n\tthis.order = [\r\n\t\t['!'],\r\n\t\t['**'],\r\n\t\t['\\\\', '/', '*', '%'],\r\n\t\t['+', '-'],\r\n\t\t['<<', '>>'],\r\n\t\t['<', '<=', '>', '>='],\r\n\t\t['==', '=', '!=', '<>'],\r\n\t\t['&'], ['^'], ['|'],\r\n\t\t['&&'], ['||']\r\n\t];\r\n\r\n\tthis.prefixOps = ['!'];\r\n\tthis.suffixOps = ['!'];\r\n\r\n\t// See: https://en.wikipedia.org/wiki/Operator_associativity\r\n\tthis.rightAssociativeOps = {\r\n\t\t'**': true\r\n\t}\r\n\r\n\tthis.flatOps = [];\r\n\tfor (var i=0; i < this.order.length; i++) {\r\n\t\tthis.flatOps = this.flatOps.concat(this.order[i]);\r\n\t}\r\n\r\n\tthis.CONSTANT = {};\r\n\tthis.FUNCTION = {};\r\n};\r\n\r\n// Built-in constant values\r\nParser.prototype.DEFAULT_CONSTANTS = {\r\n\t'PI': Math.PI,\r\n\t'LOG2E': Math.LOG2E,\r\n\t'DEG': Math.PI / 180,\r\n\t'E': Math.E\r\n};\r\n\r\nParser.prototype.FORCE_CONSTANTS = {\r\n\t'INFINITY': Infinity,\r\n\t'NAN': NaN,\r\n\t'TRUE': true,\r\n\t'FALSE': false\r\n};\r\n\r\nParser.prototype.exec = function(expression) {\r\n\ttry {\r\n\t\treturn this.execute(expression);\r\n\t} catch (ignored) {\r\n\t\treturn 'ERROR';\r\n\t}\r\n};\r\n\r\nParser.prototype.execute = function(expression) {\r\n\tvar compiled;\r\n\r\n\tif (expression['__compiled_expression']) {\r\n\t\tcompiled = expression;\r\n\t} else {\r\n\t\tcompiled = this._evaluateToken(compiled);\r\n\t}\r\n};\r\n\r\nParser.prototype._opAtPosition = function(s, p) {\r\n\tvar op = '';\r\n\r\n\tfor (var j=0, jlen = this.flatOps.length; j < jlen; j++) {\r\n\t\tvar item = this.flatOps[j];\r\n\t\tif (op == item || item.length <= op.length) continue;\r\n\t\tif (s.substr(p, item.length) === item) op = item;\r\n\t}\r\n\r\n\treturn op;\r\n};\r\n\r\nParser.prototype._indexOfOpInTokens = function(tokens, op) {\r\n\tfor (var i=0; i < tokens.length; i++) {\r\n\t\tvar token = tokens[i];\r\n\t\tif (token.type === TokenType.OP && token.value === op)\r\n\t\t\treturn i;\r\n\t}\r\n\r\n\treturn -1;\r\n};\r\n\r\nParser.prototype._lastIndexOfOpInTokens = function(tokens, op) {\r\n\tfor (var i=tokens.length - 1; i >= 0; i--) {\r\n\t\tvar token = tokens[i];\r\n\t\tif (token.type === TokenType.OP && token.value === op) return i;\r\n\t}\r\n\r\n\treturn -1;\r\n};\r\n\r\nParser.prototype._lastIndexOfOpArray = function(tokens, cs) {\r\n\tvar l = -1, p, m, item;\r\n\r\n\tfor (var i=0; i < cs.length; i++) {\r\n\t\titem = cs[i];\r\n\r\n\t\tif (this.rightAssociativeOps.hasOwnProperty(item)) {\r\n\t\t\tp = this._indexOfOpInTokens(tokens, item);\r\n\t\t} else {\r\n\t\t\tp = this._lastIndexOfOpInTokens(tokesn, item);\r\n\t\t}\r\n\r\n\t\tif (p == -1)\r\n\t\t\tcontinue;\r\n\r\n\t\tif (l == -1 || p > 1) {\r\n\t\t\tl = p;\r\n\t\t\tm = item;\r\n\t\t}\r\n\t}\r\n\r\n\treturn [l, m];\r\n};\r\n\r\nParser.prototype._parseNumber = function(data, startAt) {\r\n\tvar i = startAt || 0, len = data.length;\r\n\tvar c;\r\n\tvar exp = 0;\r\n\tvar dec = false;\r\n\r\n\tif (i >= len) {\r\n\t\tthrow new Error(\"Can't parse token at: \" + i);\r\n\t}\r\n\r\n\tfor (; i < len; i++) {\r\n\t\tc = data[i];\r\n\r\n\t\tif (c >= '0' && c <= '9') {\r\n\t\t\tif (exp == 1) break;\r\n\t\t\tif (exp > 1) exp++;\r\n\t\t} else if (c === '.') {\r\n\t\t\tif (dec || exp > 0) break;\r\n\t\t\tdec = true;\r\n\t\t} else if (c === 'e') {\r\n\t\t\tif (exp > 0) break;\r\n\t\t\texp = 1;\r\n\t\t} else if (exp === 1 && (c === '-' || c === '+')) {\r\n\t\t\texp = 2;\r\n\t\t} else {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif(i === startAt || exp === 1 || exp === 2) {\r\n\t\tthrow new Error('Unexpected character at: ' + i);\r\n\t}\r\n\r\n\treturn [data.substr(startAt, i - startAt), i];\r\n};\r\n\r\nParser.prototype._tokenizeExpression = function(expression) {\r\n\tvar tokens = [];\r\n\tvar parsed;\r\n\r\n\tfor (var i=0, len = expression.length; i < len; i++) {\r\n\t\tvar c = expression[i];\r\n\t\tvar isDigit = c >= '0' && c <= '9';\r\n\r\n\t\tif (isDigit || c === '.') {\r\n\t\t\t// Start of a number\r\n\t\t\tparsed = this._parseNumber(expression, i);\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TokenType.NUMBER,\r\n\t\t\t\tpos: i,\r\n\t\t\t\tvalue: parsed[0]\r\n\t\t\t});\r\n\t\t\ti = parsed[1] - 1;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c === '(') {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TokenType.L_PAREN,\r\n\t\t\t\tpos: i\r\n\t\t\t});\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c === ')') {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype:TokenType.R_PAREN,\r\n\t\t\t\tpos: i\r\n\t\t\t});\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c === ',') {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TokenType.COMMA,\r\n\t\t\t\tpos: i \r\n\t\t\t});\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c === ' ' || c === '\\t' || c === '\\r' || c === '\\n') {\r\n\t\t\t// Skip whitespace\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tvar op = this._opAtPosition(expression, i);\r\n\t\tif (op) {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TokenType.OP,\r\n\t\t\t\tpos: i,\r\n\t\t\t\tvalue: op\r\n\t\t\t});\r\n\r\n\t\t\ti += op.length - 1;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tthrow new Error('Unexpected token at Index ' + i);\r\n\t}\r\n\r\n\treturn tokens;\r\n}\r\n\r\nParser.prototype._groupTokens = function(tokens, startAt) {\r\n\tvar isFunc = startAt > 0 && tokens[startAt - 1].type === TokenType.VAR;\r\n\tvar rootToken = tokenss[isFunc ? startAt - 1: startAt];\r\n\tvar token, groups, sub;\r\n\r\n\tif (isFunc) {\r\n\t\trootToken.type = TokenType.CALL;\r\n\t\tgroups = rootTokens.args = [];\r\n\t\tsub = [];\r\n\t} else {\r\n\t\trootToken.type = TokenType.GROUP;\r\n\t\tsub = rootToken.tokens = [];\r\n\t}\r\n\r\n\tfor (var i = startAt + 1, len = tokens.length; i < len; i++) {\r\n\t\ttoken = tokens[i];\r\n\r\n\t\tif (isFunc && token.type === TokenType.COMMA) {\r\n\t\t\tsub = [];\r\n\t\t\tgroups.push(sub);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (token.type === TokenType.R_PAREN) {\r\n\t\t\tif (isFunc) {\r\n\t\t\t\ttokens.splice(startAt, i - startAt + 1);\r\n\t\t\t} else {\r\n\t\t\t\ttokens.splice(startAt + 1, i - startAt);\r\n\t\t\t}\r\n\r\n\t\t\treturn rootToken;\r\n\t\t}\r\n\r\n\t\tif (token.type === TokenType.L_PAREN) {\r\n\t\t\tthis._groupTokens(tokens, i);\r\n\t\t\ti--;\r\n\t\t\tlen = tokens.length;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (isFunc && groups.length === 0) {\r\n\t\t\tgroups.push(sub);\r\n\t\t}\r\n\r\n\t\tsub.push(token);\r\n\t}\r\n\r\n\tthrow new Error(\"Unmatched parenthesis at \" + tokens[startAt].pos);\r\n};\r\n\r\nParser.prototype._buildTree = function(tokens) {\r\n\tvar order = this.order, orderCount = order.length;\r\n\tvar cs, found, pos, op;\r\n\tvar left, right;\r\n\r\n\tfor (var i=orderCount - 1; i >= 0; i--) {\r\n\t\tcs = order[i];\r\n\t\tfound = this._lastIndexOfOpArray(tokens, cs);\r\n\t\tpos = found[0];\r\n\t\top = found[1];\r\n\r\n\t\tif (pos !== -1) {\r\n\t\t\tvar token = tokens[pos];\r\n\r\n\t\t\tif (this.prefixOps.indexOf(op) !== -1 || this.suffixOps.indexOf(op) !== -1) {\r\n\t\t\t\tleft = null;\r\n\t\t\t\tright = null;\r\n\r\n\t\t\t\tif (this.prefixOps.indexOf(op) !== -1 && pos == 0) {\r\n\t\t\t\t\tright = tokens.slice(pos + 1);\r\n\t\t\t\t} else if (this.suffixOps.indexOf(op) !== -1 && pos > 0) {\r\n\t\t\t\t\tleft = tokens.slice(0, pos);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (left === null && right === null) {\r\n\t\t\t\t\tthrow new Error('Operator ' + token.value + ' is unexpected at index ' + token.pos);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tleft = tokens.slice(0, pos);\r\n\t\t\t\tright = tokens.slice(pos + 1);\r\n\r\n\t\t\t\tif (left.length === 0 && (op === '-' || op === '+')) {\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ((left && left.length === 0) || (right && right.length === 0)) {\r\n\t\t\t\tthrow new Error('Invalide expression, missing operand');\r\n\t\t\t}\r\n\r\n\t\t\tif (!left && op === '-') {\r\n\t\t\t\tleft = [{type: TokenType.NUMBER, value: 0}];\r\n\t\t\t} else if (!left && op === '+') {\r\n\t\t\t\treturn this._buildTree(right);\r\n\t\t\t}\r\n\r\n\t\t\tif (left) {\r\n\t\t\t\ttoken.left = this._buildTree(left);\r\n\t\t\t}\r\n\r\n\t\t\tif (right) {\r\n\t\t\t\ttoken.right = this._buildTree(right);\r\n\t\t\t}\r\n\r\n\t\t\treturn token;\r\n\t\t}\r\n\t}\r\n\r\n\tif (tokens.length > 1) {\r\n\t\tthrow new Error('Invalid expression, missing operand or operator at ' + tokens[1].pos);\r\n\t}\r\n\r\n\tif (tokens.length === 0) {\r\n\t\tthrow new Error('Invalid expression, missing operand or operator.');\r\n\t}\r\n\r\n\tvar singleToken = tokens[0];\r\n\r\n\tif (singleToken.type === TokenType.GROUP) {\r\n\t\tsingleToken = this._buildTree(singleToken.tokens);\r\n\t} else if (singleToken.type === TokenType.CALL) {\r\n\t\tfor (var a = 0, arglen = singleToken.args.length; a < arglen; a++) {\r\n\t\t\tif (singleToken.args[a].length === 0)\r\n\t\t\t\tsingleToken.args[a] = null;\r\n\t\t\telse\r\n\t\t\t\tsingleToken.args[a] = this._buildTree(singleToken.args[a]);\r\n\t\t}\r\n\t} else if (singleToken.type === TokenType.COMMA) {\r\n\t\tthrow new Error('Unexpected character at index ' + singleToken.pos);\r\n\t}\r\n\r\n\treturn singleToken;\r\n};\r\n\r\nParser.prototype.compile = function(expression) {\r\n\tvar tokens = this._tokenizeExpression(expression);\r\n\tvar token, prevToken, i, len;\r\n\r\n\tfor (i=1, len = tokens.length; i < len; i++) {\r\n\t\ttoken = tokens[i];\r\n\t\tprevToken = tokens[i - 1];\r\n\r\n\t\tif (token.type === TokenType.OP && \r\n\t\t\t(token.value === '-' || token.value === '+') &&\r\n\t\t\tprevToken.type === TokenType.Op &&\r\n\t\t\t(prevToken.value === '-' || prevToken.value === '+')) {\r\n\r\n\t\t\tif (prevToken.value !== '+') {\r\n\t\t\t\tif (token.value === '-') {\r\n\t\t\t\t\ttoken.value = '+';\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttoken.value = '-';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttokens.splice(i-1, 1);\r\n\t\t\ti--;\r\n\t\t\tlen = tokens.length;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (token.type === TokenType.NUMBER &&\r\n\t\t\tprevToken.type === TokenType.OP &&\r\n\t\t\t(prevToken.value === '-' || prevToken.value === '+') &&\r\n\t\t\t((i > 1 && tokens[i - 2].type === TokenType.OP) || i === 1)) {\r\n\r\n\t\t\tif (prevToken.value === '-') {\r\n\t\t\t\ttoken.value = prevToken.value + token.value;\r\n\t\t\t}\r\n\t\t\ttokens.splice(i-1, 1);\r\n\t\t\ti--;\r\n\t\t\tlen = tokens.length;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t}\r\n\r\n\t// Deal with grouping\r\n\tfor (i=0, len=tokens.length; i < len; i++) {\r\n\t\ttoken = tokens[i];\r\n\r\n\t\tif (token.type === TokenType.L_PAREN) {\r\n\t\t\tthis._groupTokens(tokens, i);\r\n\t\t\tlen = tokens.length;\r\n\t\t\ti--;\r\n\t\t}\r\n\t}\r\n\r\n\t// Build the tree\r\n\tvar tree = this._buildTree(tokens);\r\n\ttree['__compiled_expression'] = true;\r\n\r\n\treturn tree;\r\n};\r\n\r\nParser.prototype._evaluateToken = function(token) {\r\n\tvar value = token.value;\r\n\r\n\tswitch (token.type) {\r\n\t\tcase TokenType.NUMBER:\r\n\t\t\treturn this.number(value);\r\n\t\tcase TokenType.VAR:\r\n\t\t\tif (typeof this.FORCE_CONSTANTS[value.toUpperCase()] !== 'undefined')\r\n\t\t\t\treturn this.FORCE_CONSTANTS[value.toUpperCase()];\r\n\t\t\tif (typeof this.CONSTANT[value] !== 'undefined')\r\n\t\t\t\treturn this.CONSTANT[value];\r\n\t\t\tif (typeof this.DEFAULT_CONSTANTS[value.toUpperCase()] !== 'undefined')\r\n\t\t\t\treturn this.DEFAULT_CONSTANTS[value.toUppperCase()];\r\n\t\t\treturn undefined;\r\n\t\tcase TokenType.CALL:\r\n\t\t\treturn this._evaluateFunction(token);\r\n\t\tcase TokenType.OP:\r\n\t\t\tvar res;\r\n\t\t\tswitch (token.value) {\r\n\t\t\t\tcase '!': // Factorial or NOT\r\n\t\t\t\t\tif (token.left) {\r\n\t\t\t\t\t\t// Factorial\r\n\t\t\t\t\t\treturn this.fac(this._evaluateToken(token.left));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// NOT\r\n\t\t\t\t\t\treturn this.logicalNot(this._evaluateToken(token.right));\r\n\t\t\t\t\t}\r\n\t\t\t\tcase '/':\r\n\t\t\t\tcase '\\\\':\r\n\t\t\t\t\treturn this.div(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '*':\r\n\t\t\t\t\treturn this.mul(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '+':\r\n\t\t\t\t\treturn this.add(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '-': \r\n\t\t\t\t\treturn this.sub(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '<<': // Shift left\r\n\t\t\t\t\treturn this.shiftLeft(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '>>': // Shift right\r\n\t\t\t\t\treturn this.shiftRight(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '<': // Less than\r\n\t\t\t\t\treturn this.lessThan(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '<=': // Less than or equals to\r\n\t\t\t\t\treturn this.lessThanOrEqualsTo(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '>': // Greater than\r\n\t\t\t\t\treturn this.greaterThan(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '>=': // Greater than or equals to\r\n\t\t\t\t\treturn this.greaterThanOrEqualsTo(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '==': // Equals to\r\n\t\t\t\tcase '=':\r\n\t\t\t\t\treturn this.equalsTo(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '!=': // Not equals to\r\n\t\t\t\tcase '<>':\r\n\t\t\t\t\treturn this.notEqualsTo(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '**': // Power\r\n\t\t\t\t\treturn this.pow(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '%': // Mod\r\n\t\t\t\t\treturn this.mod(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '&': // Bitwise AND\r\n\t\t\t\t\treturn this.and(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '^': // Bitwise XOR\r\n\t\t\t\t\treturn this.xor(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '|': // Bitwise OR\r\n\t\t\t\t\treturn this.or(this._evaluateToken(token.left), this._evaluateToken(token.right));\r\n\t\t\t\tcase '&&': // Logical AND\r\n\t\t\t\t\tres = this._evaluateToken(token.left);\r\n\t\t\t\t\tif (this.isTruthy(res))\r\n\t\t\t\t\t\treturn this._evaluateToken(token.right);\r\n\t\t\t\t\treturn res;\r\n\t\t\t\tcase '||': // Logical OR\r\n\t\t\t\t\tres = this._evaluateToken(token.left);\r\n\t\t\t\t\tif (!this.isTruthy(res))\r\n\t\t\t\t\t\treturn this._evaluateToken(token.right);\r\n\t\t\t\t\treturn res;\r\n\t\t\t}\r\n\r\n\t}\r\n\r\n\tthrow new Error('An unexpected error occured while evaluating!');\r\n};\r\n\r\nParser.prototype._evaluateFunction = function(token) {\r\n\tvar fname = token.value;\r\n\tvar args = [];\r\n\r\n\tfor (var i=0; i < token.args.length; i++) {\r\n\t\tif (token.args[i] === null)\r\n\t\t\targs.push(undefined);\r\n\t\telse\r\n\t\t\targs.push(this._evaluateToken(token.args[i]));\r\n\t}\r\n\r\n\tif (typeof(this.FUNCTION[fname]) === 'function') {\r\n\t\treturn this.FUNCTION[fname].apply(this.FUNCTION[fname], args);\r\n\t}\r\n\telse if (typeof(this[fname]) === 'function') {\r\n\t\treturn this[fname].apply(this, args);\r\n\t}\r\n\telse if (typeof(Math[fname]) == 'function') {\r\n\t\treturn Math[fname].apply(Math, args);\r\n\t}\r\n\telse if (typeof(root[fname]) == 'function') {\r\n\t\treturn root[fname].apply(root, args);\r\n\t}\r\n\r\n\tthrow new Error('Function named \"' + fname + '\" was not found');\r\n};\r\n\r\nParser.prototype.number = function(str) {\r\n\treturn Number(str);\r\n}\r\n\r\nParser.prototype.add = function(a, b) {\r\n\treturn a + b;\r\n}\r\n\r\nParser.prototype.sub = function(a, b) {\r\n\treturn a - b;\r\n}\r\n\r\nParser.prototype.mul = function(a, b) {\r\n\treturn a * b;\r\n}\r\n\r\nParser.prototype.div = function(a, b) {\r\n\treturn a / b;\r\n}\r\n\r\nParser.prototype.pow = function(a, b) {\r\n\treturn Math.pow(a, b);\r\n}\r\n\r\nParser.prototype.lessThan = function(a, b){\r\n\treturn a < b;\r\n};\r\n\r\nParser.prototype.lessThanOrEqualsTo = function(a, b){\r\n\treturn a <= b;\r\n};\r\n\r\nParser.prototype.greaterThan = function(a, b){\r\n\treturn a > b;\r\n};\r\n\r\nParser.prototype.greaterThanOrEqualsTo = function(a, b){\r\n\treturn a >= b;\r\n};\r\n\r\nParser.prototype.equalsTo = function(a, b){\r\n\treturn a == b;\r\n};\r\n\r\nParser.prototype.notEqualsTo = function(a, b){\r\n\treturn a != b;\r\n};\r\n\r\nParser.prototype.isTruthy = function(a){\r\n\treturn !!a;\r\n};\r\n\r\nParser.prototype.logicalNot = function(n){\r\n\treturn !this.isTruthy(n);\r\n};\r\n\r\nParser.prototype.fac = function(n){\r\n\tvar s = 1;\r\n\tfor (var i = 2; i <= n; i++)\r\n\t\ts = this.mul(s, i);\r\n\treturn s;\r\n};\r\n\r\nParser.prototype.mod = function(a, b){\r\n\treturn a % b;\r\n};\r\n\r\nParser.prototype.shiftLeft = function(a, b){\r\n\treturn a << b;\r\n};\r\n\r\nParser.prototype.shiftRight = function(a, b){\r\n\treturn a >> b;\r\n};\r\n\r\nParser.prototype.and = function(a, b){\r\n\treturn a & b;\r\n};\r\n\r\nParser.prototype.xor = function(a, b){\r\n\treturn a ^ b;\r\n};\r\n\r\nParser.prototype.or = function(a, b){\r\n\treturn a | b;\r\n};\r\n\r\nexport function Calculator() {\r\n\r\n\t// Converts an infix expression to postfix\r\n\t// This is using the Shunting Yard Algorithm\r\n\tthis.toPostfix = function(expression) {\r\n\t\tvar out = \"\"; // The output queue\r\n\t\tvar stack = []; // The operators stack\r\n\r\n\t\t// Opeartor definitions\r\n\t\tvar operators = {\r\n\t\t\t\"^\": {\r\n\t\t\t\tprecedence: 4,\r\n\t\t\t\tassociativity: \"right\"\r\n\t\t\t},\r\n\r\n\t\t\t\"/\": {\r\n\t\t\t\tprecedence: 3,\r\n\t\t\t\tassociativity: \"left\"\r\n\t\t\t}, \r\n\r\n\t\t\t\"*\": {\r\n\t\t\t\tprecedence: 3,\r\n\t\t\t\tassociativity: \"left\"\r\n\t\t\t},\r\n\r\n\t\t\t\"+\": {\r\n\t\t\t\tprecedence: 2,\r\n\t\t\t\tassociativity: \"left\"\r\n\t\t\t},\r\n\r\n\t\t\t\"-\": {\r\n\t\t\t\tprecedence: 2,\r\n\t\t\t\tassociativity: \"left\"\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Removes one or more occurences of whitespace globally\r\n\t\texpression = expression.replace(/\\s+/g, \"\");\r\n\t\t// Searches for operators and splits the expression on them\r\n\t\texpression = expression.split(/([\\+\\-\\*\\/\\^\\(\\)])/).clean();\r\n\r\n\t\t// Parse the expression\r\n\t\tfor (var i=0; i < expression.length; i++) {\r\n\t\t\tvar token = expression[i];\r\n\r\n\t\t\tif (token.isNumeric()) {\r\n\t\t\t\tout += token + \" \";\r\n\t\t\t} else if (\"^*/+-\".indexOf(token) !== -1) {\r\n\t\t\t\t// This is an operator token\r\n\t\t\t\tvar a = token;\r\n\t\t\t\tvar b = stack[stack.length - 1];\r\n\r\n\t\t\t\twhile (\"^*/+-\".indexOf(b) !== -1 && ((operators[a].associativity == \"left\" && operators[a].precedence <= operators[b].precedence) || \r\n\t\t\t\t\toperators[a].associativity == \"right\" && operators[b].precedence < operators[b].precedence)) {\r\n\t\t\t\t\tout += stack.pop() + \" \";\r\n\t\t\t\t\tb = stack[stack.length - 1];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstack.push(a);\r\n\t\t\t} else if (token == \"(\") {\r\n\t\t\t\tstack.push(token);\r\n\t\t\t} else if (token == \")\") {\r\n\t\t\t\twhile (stack[stack.length - 1] !== \"(\") {\r\n\t\t\t\t\tout += stack.pop() + \" \";\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstack.pop();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twhile (stack.length > 0) {\r\n\t\t\tout += stack.pop() + \" \";\r\n\t\t}\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\t// Given an expression in postifx, solve it\r\n\tthis.calc = function(postfix) {\r\n\t\tvar stack = []; // The result stack\r\n\r\n\t\t// Split the postfix on spaces\r\n\t\tpostfix = postfix.split(\" \").clean();\r\n\r\n\t\t// Solve it!\r\n\t\tfor (var i=0; i < postfix.length; i++) {\r\n\t\t\tif (postfix[i].isNumeric()) {\r\n\t\t\t\tstack.push(postfix[i]);\r\n\t\t\t} else { // Operator\r\n\t\t\t\tvar a = stack.pop();\r\n\t\t\t\tvar b = stack.pop();\r\n\r\n\t\t\t\tif (postfix[i] === \"+\") {\r\n\t\t\t\t\tstack.push(parseFloat(a) + parseFloat(b));\r\n\t\t\t\t} else if (postfix[i] === \"-\") {\r\n\t\t\t\t\tstack.push(parseFloat(b) - parseFloat(a));\r\n\t\t\t\t} else if (postfix[i] === \"*\") {\r\n\t\t\t\t\tstack.push(parseFloat(a) * parseFloat(b));\r\n\t\t\t\t} else if (postfix[i] === \"/\") {\r\n\t\t\t\t\tstack.push(parseFloat(b) / parseFloat(a));\r\n\t\t\t\t} else if (postfix[i] === \"^\") {\r\n\t\t\t\t\tstack.push(Math.pow(parseFloat(b), parseFloat(a)));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (stack.length > 1) {\r\n\t\t\treturn \"Syntax Error\";\r\n\t\t} else {\r\n\t\t\treturn stack.pop();\r\n\t\t}\r\n\t}\r\n\r\n}"]}